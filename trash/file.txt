
		//continue;		
		// Absolute approach
		//this.nodeToLabel.clear();

		for(var id in visible) {
			var label = id in idToLabel ? idToLabel[id] : "(no label)";
			
			this.nodeToLabel.put(id, label);
		}
		//console.log("NodeToLabel", this.nodeToLabel);
		//console.log("IdToLabel", idToLabel);
		//console.log("visible", visible);
			

		// (Clear boxes of loaded nodes just in case)
		// TODO Get rid of that
		
		
		
		// Add boxes for those nodes that have not been loaded
					
		// Remove markers of removed nodes
		for(var i in change.removedNodes) {
			var node = change.removedNodes[i];
			
			if(node.isLoaded) {
				var ids = _.keys(node.idToPos);					
				this.mapWidget.removeItems(ids);
			} else {
				this.mapWidget.removeBox(node.getBounds().toString());
			}
		}
	
	
		// Add markers of new nodes
		for(var i in change.addedNodes) {
			var node = change.addedNodes[i];
			
			//if(node.infMinItemCount && node.idToPos.length != 0) {
			if(node.isLoaded) {
				for(var id in node.idToPos) {
					var pos = node.idToPos[id];
					var lonlat = new OpenLayers.LonLat(pos.x, pos.y);
					//console.debug("Adding marker", id, pos, lonlat);
					
					this.mapWidget.addItem(id, lonlat, true);
				}
			} else {
				this.mapWidget.addBox(node.getBounds().toString(), toOpenLayersBounds(node.getBounds()));
			}
		}	

	//alert("Creating facet config for FTS");
	
	//var sparqlService = new VirtuosoSparqlService("http://localhost/sparql", ["http://fintrans.publicdata.eu/ec/"]);
/*
	var s = ssb.Node.v("s");
	var b = ssb.Node.v("b");
	var c = ssb.Node.v("c");
	var d = ssb.Node.v("d");
	var x = ssb.Node.v("x");
	var y = ssb.Node.v("y");
	
	
	//var p = ssb.Node.v("p");
	//var o = ssb.Node.v("o");

	var a = ssb.Node.uri("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");		
	
	var subvention = ssb.Node.uri("http://fintrans.publicdata.eu/ec/ontology/Subvention");
	var beneficiary = ssb.Node.uri("http://fintrans.publicdata.eu/ec/ontology/beneficiary");
	var city = ssb.Node.uri("http://fintrans.publicdata.eu/ec/ontology/city");
	var sameAs = ssb.Node.uri("http://www.w3.org/2002/07/owl#sameAs");

	var long = ssb.Node.uri("http://www.w3.org/2003/01/geo/wgs84_pos#long");
	var lat = ssb.Node.uri("http://www.w3.org/2003/01/geo/wgs84_pos#lat");

	var rdfsLabel = ssb.Node.uri("http://www.w3.org/2000/01/rdf-schema#label");



	var config = new facets.FacetConfig(s, driver);		

	
	var l = ssb.Node.v("l");
	var varToLabelElement = new ssb.ElementTriplesBlock([new ssb.Triple(s, rdfsLabel, l)]); 
*/
	/*
	var triplesX = pathManager.toTriples("http://fintrans.publicdata.eu/ec/ontology/beneficiary http://fintrans.publicdata.eu/ec/ontology/city http://www.w3.org/2003/01/geo/wgs84_pos#long");
	console.log("Triples: ", triplesX.toString());
	
	var triplesY = pathManager.toTriples("http://fintrans.publicdata.eu/ec/ontology/beneficiary http://fintrans.publicdata.eu/ec/ontology/city http://www.w3.org/2003/01/geo/wgs84_pos#lat");
	console.log("Triples: ", triplesY.toString());
	*/
	
	//var test = varToLabelElement.copySubstitute(function(node) { if(node.isVar()) { return ssb.Node.v("blubb"); }});
	//alert("Test substitution of a variable: " + test.toString());

	//var fa = config.getOrCreate(beneficiary.toString(), )
	
	//var fa = new facets.Facet(config.getRoot(), "beneficiary", new ssb.ElementTriplesBlock([new ssb.Triple(s, beneficiary, b)]), s, varToLabelElement); 
	//var fb = new facets.Facet(fa, "city", new ssb.ElementTriplesBlock([new ssb.Triple(b, city, c)], s, varToLabelElement)); 
	//var fc = new facets.Facet(fb, "sameCityAs", new ssb.ElementTriplesBlock([new ssb.Triple(c, sameAs, d)], s, varToLabelElement)); 
	//var fd = new facets.Facet(fc, "geoLoc", new ssb.ElementTriplesBlock([new ssb.Triple(d, long, x), new ssb.Triple(d, lat, y)], s, varToLabelElement)); 

	/*
	var fd = new facets.FacetWgs.create("geoFacet", d, x, y); 

	var c = fd.constrainBBox("foo", new Bounds(0, 1, 2, 4));
	console.log("Constraint", c);
	var element = c.toElement();
	var str = element.toString();
	console.log("element str", str);
	*/
	
	
	//config.getRoot().addSubFacet("beneficiary", s, new ssb.ElementTriplesBlock([new ssb.Triple(s, beneficiary, b)]))
	
/*
 * [
 *   ?s bene ?b .
 *   ?b city ?c .
 *   ?c sameas ?d .
 *   {?d lat ?x; long ?y}
 * ]
 * 
 * */
	

	
	
	
	// Design Issues:
	
	// "The nature of facets"
	// A facet corresponds to a static SPARQL query element. Static means, that a facet is not intended to be instanciated
	// (instanciate could mean: creating a copy of the query fragment with variables renamed (except for the driverVar).
	// The variables of the query element can be constrained.
	// A facet can be "enforced" i.e. the query element must be part of the final query, even if it is not constrained.

	// Selection order within the geo-facet path:
	// Is it a path or a tree?
	
	// How to deal with histograms??? -> Maybe use the facet value concept again? No, because a value may fall into the range of a facet group.
	
	// Should every element of the path contain its whole sequence of predecessors?

	// Issue [Multiple constraints on the same facets]
	// This should usually result in a logical or between all the constraints - but is that reasonable in all cases?
	
	// Issue [Constraints on connected/dependent facets]
	
	
	
	// eventually, we end up with a geofacet --- maybe a shallow triple pattern parser would help us?
	
	
	
	//var element = new ssb.ElementTriplesBlock([new ssb.Triple(s, p, o)]);
	
	
				/*
			console.log(graph);
			
		
			var pso = {};
			
			for(var j = 0; j < graph.length; ++j) {
				var triple = graph[j];
				
				var p = triple.p.toString();
				var so;
				if(p in pso) {
					so = pso[p];
				} else {
					pso[p] = so = {};
				}
				
				var s = triple.s.toString();
				var o;
				if(s in so) {
					o = so[s];
				} else {
					so[s] = o = [];
				}
				
				o.push(triple.o);				
			}

			var long = pso[geo.log];
			var lat = pso[geo.lat];
			var geomToCoord = {};
			
			for(var k in long) {
				var ys = long[k];
				var xs = lat[k];
				
				if(xs && ys && ys.length == 1 && xs.length == 1) {
					geomToCoord[k] = new OpenLayers.LonLat(xs[0], ys[0]);
				}
			}
			
			console.log(geomToCoord);
			//var geoRelated = pso[geovocab.geometry.toString()];
			*/
	