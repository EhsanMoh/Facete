(function() {
	
	var ns = Namespace("org.aksw.ssb.app.controllers");
	var sparql = Namespace("org.aksw.ssb.sparql.syntax");
	var facets = Namespace("org.aksw.ssb.facets");

	var rdf = Namespace("org.aksw.ssb.vocabs.rdf");
	var rdfs = Namespace("org.aksw.ssb.vocabs.rdfs");
	
	/**
	 * 
	 * 
	 * 
	 */
	ns.AppController = function(options) {
		this.options = options;
		
	
		/* Query generation */
		
		// The driver is a query element which specifies which resources to fetch
		// (e.g. ?s a Subvention)
		// The driverVar is a variable of the driver element (e.g. ?s) 
		this.driver = options.driver;
		this.driverVar = options.driverVar;
		
		// The path manager can create query elements for property paths
		// such as (knows label) -> ?x knows ?y . ?y label ?z.
		// Common paths will have the same variables in the corresponding query element
		this.pathManager = options.pathManager;
		
		// A factory for creating query elements that
		// correspond to boundary constraints (e.g. whenever the map view changes) 
		this.geoConstraintFactory = options.geoConstraintFactory;
		
		// A list of constraint objects that need to be included in the final query
		// Such as generated by the facet view
		this.constraints = [];
		
		
		// A list of paths for which to fetch data
		// TODO Not sure how components should declare that
	};

	/**
	 * Creates a SPARQL query for fetching resources, geo-coordinates, labels (and possibly more)
	 * based on all available constraints.
	 *
	 * Returns an object with the query object, and a set of semantic mappings of the queryies
	 * variable (e.g. {label: v_1}
	 * 
	 */
	ns.AppController.prototype.createQuery = function(bounds) {
		
		var query = new sparql.Query();
		
		query.elements.push(this.driver);
		
		for(var i = 0; i < this.constraints.length; ++i) {
			// Create query element and filter expression
		}
		
		var geoConstraint = this.geoConstraintFactory.create(bounds);
		
		var triplesBlock = new sparql.ElementTriplesBlock();
		
		query.elements.push(triplesBlock);
		triplesBlock.addTriples(this.geoConstraintFactory.getTriples());
		
	
		query.elements.push(new sparql.ElementFilter(geoConstraint.getExpr()));
				
		

		//this.geoConstraintFactory

		var geomVar = this.geoConstraintFactory.breadcrumb.targetNode.variable;
		var xVar = this.geoConstraintFactory.breadcrumbX.targetNode.variable;
		var yVar = this.geoConstraintFactory.breadcrumbY.targetNode.variable;
		
		
		// TODO We need to find out the variables which should be fetched.
		var labelBc = new facets.Breadcrumb.fromString(this.pathManager, rdfs.label.value);
		var typeBc = new facets.Breadcrumb.fromString(this.pathManager, rdf.type.value);
		
		triplesBlock.addTriples(labelBc.getTriples());
		triplesBlock.addTriples(typeBc.getTriples());
		
		triplesBlock.uniq();
		
		query.projection[geomVar] = null;
		query.projection[xVar] = null;
		query.projection[yVar] = null;
		query.projection[labelBc.targetNode.variable] = null;
		
		var bindings = {geom: geomVar, x: xVar, y: yVar, subject: this.driverVar.value};
		var result = {query: query, bindings: bindings};
		
		console.log("Created query and bindings:", result);
		
		return result;
		
		//alert("Creating query");
		//BreadCrumb.getTargetVariable
		//BreadCrumb.getVariables()
	};
	
	ns.AppController.prototype.setDriver = function(driver) {
		this.driver = driver;
	};
	
	ns.AppController.prototype.setGeoConstraintFactory = function(geoConstraintFactory) {
		this.geoConstraintFactory = geoConstraintFactory;
	};
	
	ns.AppController.refresh = function(bounds) {

	};

	
	/**
	 * Fetches data for the selected area.
	 * 
	 * 
	 */
	ns.AppController.refreshArea = function(bounds) {
		
	};
	

})();

